<!doctype html>
<html>
    <head>
        <title>Ed Space - Worknotes</title>
        <link href="/css/general.css" rel="stylesheet">
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css">
        <link href="/css/fortran-syntax.css" rel="stylesheet">
        <link href="/css/cpp-syntax.css" rel="stylesheet">
    </head>
    <body>
    
        <!-- Top navigation bar -->
        <nav class="navbar navbar-default sticky-top">
            <div class="container-fluid">
                <ul class="nav navbar-nav">
                    <li class="nav-item"><a href="/index.html">Home</a></li>
                    <li class="nav-item"><a href="/about.html">About Me</a></li>
                    <li class="nav-item active"><a href="/worknotes/index.html">Work Notes</a></li>
                    <li class="nav-item"><a href="/trips/index.html">Trips</a></li>
                    <li class="nav-item"><a href="/apps/index.html">Web Tools</a></li>
                  </ul>
            </div>
        </nav>
        
        <div class="normalwidth">
            <h1>Direct search for pairs of points within fixed cutoff distance</h1>
            <p>I work with point pair searches through particle-based simulations (mostly SPH and DEM). The algorithm here is the most basic way to perform a pair search. It is O(N<sup>2</sup>) time, so is not useful for any practical applications.</p>
            <p>I use it frequently to server as a reference when investigating other ways to search for pairs. It's simple to code, so is harder to introduce conceptual and coding errors.</p>
            <p>It does also have some real-world relevance, as the <a href="celllist.html">cell-list pair-search algorithm</a> uses many smaller direct searches.</p>
            <p>The Fortran code below contains the module <code>dsearch_m</code>, and a <code>main</code> program. To compile only the module, pass the <code>-DNOMAIN</code> option to the compiler, and the preprocessor will omit it.</p>
            <p>The module has the <code>dsearch</code> and <code>dsearch_compact</code> interfaces. <code>dsearch</code> returns two lists, one with the "left-sided" points of the pairs, and <code>pair_j</code>, which returns the "right-sided" points in the pair list. In contrast, <code>dsearch_compact</code> returns a shorter list, <code>endpos</code>, where <code>endpos(i)</code> corresponds to the last pair with point <code>i</code> as the "left-sided" point. See the main program for an example of how to iterate over the lists.</p>
            <p>The benefit of <code>dsearch_compact</code> is the output format has a smaller memory footprint, and iterating over the list requires fewer memory accesses and is consequently usually a bit faster. However, the drawback is that it is less intuitive and more awkward to iterate over.</p>
            <p>Download: <!--<a href="samples/sample.cu" download="sample.cu"><img src="/static/logos/cpp.svg" height="32px"></a>--> <a href="samples/dsearch.F90" download="dsearch.F90"><img src="/static/logos/Fortran.svg" height="32px"></a></p>
            <h2>C++</h2>
            <pre><code>Coming soon</code></pre>
            <h2>Fortran</h2>
            <pre><code><span class="fcomment">! Module to perform direct search for pairs of points within a fixed cutoff.</span>
<span class="fcomment">! dsearch subroutine</span>
<span class="fcomment">!   dim:      An integer defining dimension of the coordinates.</span>
<span class="fcomment">!   npoints:  An integer with number of points.</span>
<span class="fcomment">!   x:        A real/double precision array of dim x points dimension containing the list of points to find pairs of.</span>
<span class="fcomment">!   cutoff:   The distance (same type as x) which defines a pair</span>
<span class="fcomment">!   maxnpair: An integer of the maximum number of pairs expected.</span>
<span class="fcomment">!   npairs:   An integer with the number of pairs found.</span>
<span class="fcomment">!   pair_i:   An integer array of maxnpairs length with the "left-sided" point in a pair.</span>
<span class="fcomment">!   pair_j:   An integer array of maxnpairs length with the "right-sided" point in a pair.</span>

<span class="fcomment">! dsearch_compact subroutine</span>
<span class="fcomment">!   same as above, except except pair_i is replaced with endpos: a list of endlocations of the left-sided point in a</span>
<span class="fcomment">!   pair. The main program shows an example of how to iterate through along the list.</span>

<span class="fstd">module</span> dsearch_m

   <span class="fstd">interface dsearch</span>
      <span class="fstd">module procedure</span> dsearch_sp, dsearch_dp
   <span class="fstd">end</span> interface dsearch

   <span class="fstd">interface</span> dsearch_compact
      <span class="fstd">module procedure</span> dsearch_compact_sp, dsearch_compact_dp
   <span class="fstd">end interface</span> dsearch_compact

<span class="fstd">contains</span>

   <span class="fcomment">!---------------------------------------------------------------------------</span>
   <span class="fstd">subroutine</span> dsearch_sp(dim, npoints, x, cutoff, maxnpair, npairs, pair_i, pair_j)

      <span class="fstd">implicit</span> <span class="fstd">none</span>
      <span class="fstd">integer</span>, <span class="fstd">intent</span>(<span class="fstd">in</span>):: dim, npoints, maxnpair
      <span class="fstd">real</span>, <span class="fstd">intent</span>(<span class="fstd">in</span>):: x(dim, npoints), cutoff
      <span class="fstd">integer</span>, <span class="fstd">intent</span>(<span class="fstd">out</span>)::  npairs, pair_i(maxnpair), pair_j(maxnpair)
      <span class="fstd">integer</span>:: i, j
      <span class="fstd">real</span>:: xi(dim), r2

      npairs = 0
      <span class="fstd">do</span> i = 1, npoints - 1
         xi(:) = x(:, i)
         <span class="fstd">do</span> j = i + 1, npoints
            r2 = sum((xi(:) - x(:, j))**2)
            <span class="fstd">if</span> (r2 <= cutoff) <span class="fstd">then</span>
               npairs = npairs + 1
               pair_i(npairs) = i
               pair_j(npairs) = j
            <span class="fstd">end</span> <span class="fstd">if</span>
         <span class="fstd">end</span> <span class="fstd">do</span>
      <span class="fstd">end</span> <span class="fstd">do</span>

   <span class="fstd">end</span> <span class="fstd">subroutine</span> dsearch_sp

   <span class="fcomment">!---------------------------------------------------------------------------</span>
   <span class="fstd">subroutine</span> dsearch_dp(dim, npoints, x, cutoff, maxnpair, npairs, pair_i, pair_j)

      <span class="fstd">implicit</span> <span class="fstd">none</span>
      <span class="fstd">integer</span>, <span class="fstd">intent</span>(<span class="fstd">in</span>):: dim, npoints, maxnpair
      <span class="fstd">double precision</span>, <span class="fstd">intent</span>(<span class="fstd">in</span>):: x(dim, npoints), cutoff
      <span class="fstd">integer</span>, <span class="fstd">intent</span>(<span class="fstd">out</span>)::  npairs, pair_i(maxnpair), pair_j(maxnpair)
      <span class="fstd">integer</span>:: i, j
      <span class="fstd">double precision</span>:: xi(dim), r2

      npairs = 0
      <span class="fstd">do</span> i = 1, npoints - 1
         xi(:) = x(:, i)
         <span class="fstd">do</span> j = i + 1, npoints
            r2 = sum((xi(:) - x(:, j))**2)
            <span class="fstd">if</span> (r2 <= cutoff) <span class="fstd">then</span>
               npairs = npairs + 1
               pair_i(npairs) = i
               pair_j(npairs) = j
            <span class="fstd">end</span> <span class="fstd">if</span>
         <span class="fstd">end</span> <span class="fstd">do</span>
      <span class="fstd">end</span> <span class="fstd">do</span>

   <span class="fstd">end</span> <span class="fstd">subroutine</span> dsearch_dp

   <span class="fcomment">!---------------------------------------------------------------------------</span>
   <span class="fstd">subroutine</span> dsearch_compact_sp(dim, npoints, x, cutoff, maxnpair, npairs, endpos, pair_j)

      <span class="fstd">implicit</span> <span class="fstd">none</span>
      <span class="fstd">integer</span>, <span class="fstd">intent</span>(<span class="fstd">in</span>):: dim, npoints, maxnpair
      <span class="fstd">real</span>, <span class="fstd">intent</span>(<span class="fstd">in</span>):: x(dim, npoints), cutoff
      <span class="fstd">integer</span>, <span class="fstd">intent</span>(<span class="fstd">out</span>):: endpos(npoints), npairs, pair_j(maxnpair)
      <span class="fstd">integer</span>:: i, j
      <span class="fstd">real</span>:: xi(dim), r2

      npairs = 0
      <span class="fstd">do</span> i = 1, npoints
         xi(:) = x(:, i)
         <span class="fstd">do</span> j = i + 1, npoints
            r2 = sum((xi(:) - x(:, j))**2)
            <span class="fstd">if</span> (r2 <= cutoff) <span class="fstd">then</span>
               npairs = npairs + 1
               pair_j(npairs) = j
            <span class="fstd">end</span> <span class="fstd">if</span>
         <span class="fstd">end</span> <span class="fstd">do</span>
         endpos(i) = npairs
      <span class="fstd">end</span> <span class="fstd">do</span>

   <span class="fstd">end</span> <span class="fstd">subroutine</span> dsearch_compact_sp

   <span class="fcomment">!---------------------------------------------------------------------------</span>
   <span class="fstd">subroutine</span> dsearch_compact_dp(dim, npoints, x, cutoff, maxnpair, npairs, endpos, pair_j)

      <span class="fstd">implicit</span> <span class="fstd">none</span>
      <span class="fstd">integer</span>, <span class="fstd">intent</span>(<span class="fstd">in</span>):: dim, npoints, maxnpair
      <span class="fstd">double precision</span>, <span class="fstd">intent</span>(<span class="fstd">in</span>):: x(dim, npoints), cutoff
      <span class="fstd">integer</span>, <span class="fstd">intent</span>(<span class="fstd">out</span>):: endpos(npoints), npairs, pair_j(maxnpair)
      <span class="fstd">integer</span>:: i, j
      <span class="fstd">double precision</span>:: xi(dim), r2

      npairs = 0
      <span class="fstd">do</span> i = 1, npoints
         xi(:) = x(:, i)
         <span class="fstd">do</span> j = i + 1, npoints
            r2 = sum((xi(:) - x(:, j))**2)
            <span class="fstd">if</span> (r2 <= cutoff) <span class="fstd">then</span>
               npairs = npairs + 1
               pair_j(npairs) = j
            <span class="fstd">end</span> <span class="fstd">if</span>
         <span class="fstd">end</span> <span class="fstd">do</span>
         endpos(i) = npairs
      <span class="fstd">end</span> <span class="fstd">do</span>

   <span class="fstd">end</span> <span class="fstd">subroutine</span> dsearch_compact_dp

<span class="fstd">end</span> <span class="fstd">module</span> dsearch_m

<span class="fpp">#ifndef NOMAIN</span>
<span class="fstd">program</span> main

   <span class="fstd">use</span> dsearch_m, only: dsearch, dsearch_compact

   <span class="fstd">implicit</span> <span class="fstd">none</span>
   <span class="fstd">integer</span>, <span class="fstd">parameter</span>:: n = 100, dim = 3, maxnpair = 60*n <span class="fcomment"><span class="fcomment">!</span> estimated using</span>
   <span class="fcomment"><span class="fcomment">!</span> 2x the coaxial spacing if the points were arranged in a square</span>
   <span class="fstd">double precision</span>, <span class="fstd">parameter</span>:: cutoff = 2*n**(-1.d0/dim)
   <span class="fstd">double precision</span>:: x(dim, n)
   <span class="fstd">integer</span>:: pair_i(maxnpair), pair_j(maxnpair), npairs, startpos, i, j, k, endpos(n)

   <span class="fcomment"><span class="fcomment">!</span> initialize positions with pseudo-random numbers</span>
   <span class="fstd">call</span> random_number(x)

   <span class="fcomment"><span class="fcomment">!</span> finding pairs</span>
   <span class="fstd">call</span> dsearch(dim, n, x, cutoff, maxnpair, npairs, pair_i, pair_j)

   write (*, <span class="fstring"><span class="fstring">'(A)'</span></span>) <span class="fstring">'Executing <span class="fstring">"normal"</span> dsearch'</span>
   write (*, <span class="fstring"><span class="fstring">'(2x, A,I4,A)'</span></span>) <span class="fstring"><span class="fstring">'Found '</span></span>, n, <span class="fstring"><span class="fstring">' pairs'</span></span>
   write (*, <span class="fstring"><span class="fstring"><span class="fstring"><span class="fstring">'(2x, A)'</span></span></span></span>) <span class="fstring"><span class="fstring">'First and last 5 pairs of points found:'</span></span>
   write (*, <span class="fstring"><span class="fstring">'(2x, 4(A4, 1x))'</span></span>) <span class="fstring"><span class="fstring">'Pair'</span></span>, <span class="fstring"><span class="fstring">'i'</span></span>, <span class="fstring"><span class="fstring">'j'</span></span>
   <span class="fstd">do</span> k = 1, npairs
      <span class="fstd">if</span> (k <= 5 <span class="flog">.or.</span> k > npairs - 4) write (*, <span class="fstring">'(2x, 3(I4, 1x))'</span>) k, pair_i(k), pair_j(k)
      <span class="fstd">if</span> (k == 6) write (*, <span class="fstring"><span class="fstring"><span class="fstring"><span class="fstring">'(2x, A)'</span></span></span></span>) <span class="fstring"><span class="fstring">'...'</span></span>
   <span class="fstd">end</span> <span class="fstd">do</span>
   write (*, *)
   write (*, <span class="fstring"><span class="fstring">'(A)'</span></span>) <span class="fstring">'Executing <span class="fstring">"compact"</span> dsearch'</span>
   write (*, <span class="fstring"><span class="fstring">'(2x, A,I4,A)'</span></span>) <span class="fstring"><span class="fstring">'Found '</span></span>, n, <span class="fstring"><span class="fstring">' pairs'</span></span>
   write (*, <span class="fstring"><span class="fstring"><span class="fstring"><span class="fstring">'(2x, A)'</span></span></span></span>) <span class="fstring"><span class="fstring">'First and last 5 pairs of points found:'</span></span>
   write (*, <span class="fstring"><span class="fstring">'(2x, 4(A4, 1x))'</span></span>) <span class="fstring"><span class="fstring">'Pair'</span></span>, <span class="fstring"><span class="fstring">'i'</span></span>, <span class="fstring"><span class="fstring">'j'</span></span>
   <span class="fstd">call</span> dsearch_compact(dim, n, x, cutoff, maxnpair, npairs, endpos, pair_j)
   <span class="fstd">do</span> i = 1, n
      <span class="fstd">if</span> (i == 1) startpos = 1
      <span class="fstd">if</span> (i > 1) startpos = endpos(i - 1) + 1
      <span class="fstd">do</span> k = startpos, endpos(i)
         <span class="fstd">if</span> (k <= 5 <span class="flog">.or.</span> k > npairs - 4) write (*, <span class="fstring">'(2x, 3(I4,1x))'</span>) k, i, pair_j(k)
         <span class="fstd">if</span> (k == 6) write (*, <span class="fstring"><span class="fstring"><span class="fstring"><span class="fstring">'(2x, A)'</span></span></span></span>) <span class="fstring"><span class="fstring">'...'</span></span>
      <span class="fstd">end</span> <span class="fstd">do</span>
   <span class="fstd">end</span> <span class="fstd">do</span>

<span class="fstd">end</span> <span class="fstd">program</span> main
<span class="fpp">#endif</span></code></pre>
        </div>

        <hr>
        <div class="footer">
            <p>Content first published: 12 Feb 2023 &nbsp;&nbsp;&nbsp; Content last modified: 12 Feb 2023</p>
            <p><a href="mailto:edward_yang_125@hotmail.com"><img src="/static/logos/email.png"> Email</a>&nbsp;&nbsp;&nbsp; <a href="https://www.github.com/edoyango"><img src="/static/logos/github.png"> Github</a>&nbsp;&nbsp;&nbsp; <a href="https://www.linkedin.com/in/edward-yang-a0a9941b1"><img src="/static/logos/linkedin.png"> LinkedIn</a></p>
        </div>
        
    </body>
</html>
